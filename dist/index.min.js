function _unsupportedIterableToArray(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_arrayLikeToArray(e,n):void 0}}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var r=0,t=new Array(n);r<n;r++)t[r]=e[r];return t}function _createForOfIteratorHelper(e,n){var r;if("undefined"==typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(r=_unsupportedIterableToArray(e))||n&&e&&"number"==typeof e.length){r&&(e=r);var t=0,a=function(){};return{s:a,n:function(){return t>=e.length?{done:!0}:{done:!1,value:e[t++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,o=!0,s=!1;return{s:function(){r=e[Symbol.iterator]()},n:function(){var e=r.next();return o=e.done,e},e:function(e){s=!0,i=e},f:function(){try{o||null==r.return||r.return()}finally{if(s)throw i}}}}var ExhaustiveDeps={meta:{hasSuggestions:!0,type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",category:"Best Practices",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{oneOf:[{type:"string"},{type:"object",additionalProperties:{type:"number"}}]},enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"},staticHooks:{type:"object",additionalProperties:{oneOf:[{type:"boolean"},{type:"array",items:{type:"boolean"}},{type:"object",additionalProperties:{type:"boolean"}}]}}}}]},create:function(e){var n=parseAdditionalHooks(e.options&&e.options[0]&&e.options[0].additionalHooks),r=e.options&&e.options[0]&&e.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||!1,t=e.options&&e.options[0]&&e.options[0].staticHooks||{},a={additionalHooks:n,enableDangerousAutofixThisMayCauseInfiniteLoops:r,staticHooks:t};function i(n){r&&Array.isArray(n.suggest)&&n.suggest.length>0&&(n.fix=n.suggest[0].fix),e.report(n)}var o=e.getSourceCode().scopeManager,s=new WeakMap,c=new WeakSet,l=new WeakMap,u=new WeakMap;function p(e,n){return function(r){if(n.has(r))return n.get(r);var t=e(r);return n.set(r,t),t}}function f(n,r,t,f,d){d&&n.async&&i({node:n,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"});for(var y=o.acquire(n),h=new Set,m=null,g=y.upper;g&&(h.add(g),"function"!==g.type);)g=g.upper;if(g){m=g;var v=p((function(e){if(!Array.isArray(e.defs))return!1;var n=e.defs[0];if(null==n)return!1;if("VariableDeclarator"!==n.node.type)return!1;var r=n.node.init;if(null==r)return!1;for(;"TSAsExpression"===r.type;)r=r.expression;var t=n.node.parent;if(null==t&&(fastFindReferenceWithParent(m.block,n.node.id),null==(t=n.node.parent)))return!1;if("const"===t.kind&&"Literal"===r.type&&("string"==typeof r.value||"number"==typeof r.value||null===r.value))return!0;if("CallExpression"!==r.type)return!1;var i=r.callee;if("MemberExpression"!==i.type||"React"!==i.object.name||null==i.property||i.computed||(i=i.property),"Identifier"!==i.type)return!1;var o=n.node.id,l=i.name;if("useRef"===l&&"Identifier"===o.type)return!0;if("useState"===l||"useReducer"===l){if("ArrayPattern"===o.type&&2===o.elements.length&&Array.isArray(e.identifiers)){if(o.elements[1]===e.identifiers[0]){if("useState"===l)for(var u=e.references,p=0;p<u.length;p++)s.set(u[p].identifier,o.elements[0]);return!0}if(o.elements[0]===e.identifiers[0]){if("useState"===l)for(var f=e.references,d=0;d<f.length;d++)c.add(f[d].identifier);return!1}}}else if("useTransition"===l){if("ArrayPattern"===o.type&&Array.isArray(e.identifiers)&&o.elements[0]===e.identifiers[0])return!0}else if(a.staticHooks[l]){var y=a.staticHooks[l];if(!0===y)return!0;if(Array.isArray(y)){if("ArrayPattern"===o.type&&o.elements.length<=y.length&&Array.isArray(e.identifiers)){var h=o.elements.findIndex((function(n){return n===e.identifiers[0]}));if(h>=0)return y[h]}}else if("object"==typeof y&&"ObjectPattern"===o.type){var g=o.properties.find((function(n){return n.key.name===e.identifiers[0].name}));if(g)return y[g.key.name]}}return!1}),l),b=p((function(e){if(!Array.isArray(e.defs))return!1;var n=e.defs[0];if(null==n)return!1;if(null==n.node||null==n.node.id)return!1;var r,t=n.node,a=m.childScopes,i=null;for(r=0;r<a.length;r++){var o=a[r],s=o.block;if("FunctionDeclaration"===t.type&&s===t||"VariableDeclarator"===t.type&&s.parent===t){i=o;break}}if(null==i)return!1;for(r=0;r<i.through.length;r++){var c=i.through[r];if(null!=c.resolved&&(h.has(c.resolved.scope)&&!v(c.resolved)))return!1}return!0}),u),x=new Map,k=new Map,E=new Map;!function e(r){var t,a=_createForOfIteratorHelper(r.references);try{for(a.s();!(t=a.n()).done;){var i=t.value;if(i.resolved&&h.has(i.resolved.scope)){var o=getDependency(fastFindReferenceWithParent(n,i.identifier)),s=analyzePropertyChain(o,E);if(!d||"Identifier"!==o.type||"MemberExpression"!==o.parent.type&&"OptionalMemberExpression"!==o.parent.type||o.parent.computed||"Identifier"!==o.parent.property.type||"current"!==o.parent.property.name||!B(i)||x.set(s,{reference:i,dependencyNode:o}),"TSTypeQuery"!==o.parent.type&&"TSTypeReference"!==o.parent.type){var c=i.resolved.defs[0];if(null!=c&&(null==c.node||c.node.init!==n.parent)&&"TypeParameter"!==c.type)if(k.has(s))k.get(s).references.push(i);else{var l=i.resolved,u=v(l)||b(l);k.set(s,{isStable:u,references:[i]})}}}}}catch(e){a.e(e)}finally{a.f()}var p,f=_createForOfIteratorHelper(r.childScopes);try{for(f.s();!(p=f.n()).done;){var y=p.value;e(y)}}catch(e){f.e(e)}finally{f.f()}}(y),x.forEach((function(e,n){for(var r=e.reference,t=e.dependencyNode,a=r.resolved.references,o=!1,s=0;s<a.length;s++){var c=a[s].identifier.parent;if(null!=c&&"MemberExpression"===c.type&&!c.computed&&"Identifier"===c.property.type&&"current"===c.property.name&&"AssignmentExpression"===c.parent.type&&c.parent.left===c){o=!0;break}}o||i({node:t.parent.property,message:"The ref value '"+n+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+n+".current' to a variable inside the effect, and use that variable in the cleanup function."})}));var w=new Set,A=new Set;if(k.forEach((function(n,r){var a=n.isStable,o=n.references;a&&A.add(r),o.forEach((function(n){n.writeExpr&&function(n,r){w.has(r)||(w.add(r),i({node:n,message:"Assignments to the '"+r+"' variable from inside React Hook "+e.getSourceCode().getText(t)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside "+e.getSourceCode().getText(t)+"."}))}(n.writeExpr,r)}))})),!(w.size>0))if(r){var S=[],D=new Set;"ArrayExpression"!==r.type?i({node:r,message:"React Hook "+e.getSourceCode().getText(t)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."}):r.elements.forEach((function(n){if(null!==n)if("SpreadElement"!==n.type){var r;try{r=analyzePropertyChain(n,null)}catch(r){if(/Unsupported node type/.test(r.message))return void("Literal"===n.type?k.has(n.value)?i({node:n,message:"The "+n.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+n.value+" in the array instead?"}):i({node:n,message:"The "+n.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):i({node:n,message:"React Hook "+e.getSourceCode().getText(t)+" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."}));throw r}for(var a=n;"MemberExpression"===a.type||"OptionalMemberExpression"===a.type||"ChainExpression"===a.type;)a=a.object||a.expression.object;var o=!m.through.some((function(e){return e.identifier===a}));S.push({key:r,node:n}),o||D.add(r)}else i({node:n,message:"React Hook "+e.getSourceCode().getText(t)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."})}));var C=collectRecommendations({dependencies:k,declaredDependencies:S,stableDependencies:A,externalDependencies:D,isEffect:d}),T=C.suggestedDependencies,I=C.unnecessaryDependencies,R=C.missingDependencies,H=C.duplicateDependencies,j=T;if(0!==H.size+R.size+I.size){!d&&R.size>0&&(j=collectRecommendations({dependencies:k,declaredDependencies:[],stableDependencies:A,externalDependencies:D,isEffect:d}).suggestedDependencies),function(){if(0===S.length)return!0;var e=S.map((function(e){return e.key})),n=e.slice().sort();return e.join(",")===n.join(",")}()&&j.sort();var M="";if(I.size>0){var O=null;if(Array.from(I.keys()).forEach((function(e){null===O&&e.endsWith(".current")&&(O=e)})),null!==O)M=" Mutable values like '"+O+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(D.size>0){var P=Array.from(D)[0];y.set.has(P)||(M=" Outer scope values like '"+P+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!M&&R.has("props")){var z=k.get("props");if(null==z)return;var N=z.references;if(!Array.isArray(N))return;for(var F=!0,L=0;L<N.length;L++){var U=N[L],W=fastFindReferenceWithParent(m.block,U.identifier);if(!W){F=!1;break}var _=W.parent;if(null==_){F=!1;break}if("MemberExpression"!==_.type&&"OptionalMemberExpression"!==_.type){F=!1;break}}F&&(M=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+f+" call and refer to those specific props inside "+e.getSourceCode().getText(t)+".")}if(!M&&R.size>0){var V=null;R.forEach((function(e){if(!V){var n=m.set.get(e),r=k.get(e);if(r.references[0].resolved===n){var t=n.defs[0];if(null!=t&&null!=t.name&&"Parameter"===t.type){for(var a,i=!1,o=0;o<r.references.length;o++)if(null!=(a=r.references[o].identifier)&&null!=a.parent&&("CallExpression"===a.parent.type||"OptionalCallExpression"===a.parent.type)&&a.parent.callee===a){i=!0;break}i&&(V=e)}}}})),null!==V&&(M=" If '"+V+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!M&&R.size>0){var J=null;if(R.forEach((function(e){if(null===J)for(var n,r,t=k.get(e).references,a=0;a<t.length;a++){for(r=(n=t[a].identifier).parent;null!=r&&r!==m.block;){if("CallExpression"===r.type){var i=s.get(r.callee);if(null!=i){if(i.name===e)J={missingDep:e,setter:r.callee.name,form:"updater"};else if(c.has(n))J={missingDep:e,setter:r.callee.name,form:"reducer"};else{var o=t[a].resolved;if(null!=o){var l=o.defs[0];null!=l&&"Parameter"===l.type&&(J={missingDep:e,setter:r.callee.name,form:"inlineReducer"})}}break}}r=r.parent}if(null!==J)break}})),null!==J)switch(J.form){case"reducer":M=" You can also replace multiple useState variables with useReducer if '"+J.setter+"' needs the current value of '"+J.missingDep+"'.";break;case"inlineReducer":M=" If '"+J.setter+"' needs the current value of '"+J.missingDep+"', you can also switch to useReducer instead of useState and read '"+J.missingDep+"' in the reducer.";break;case"updater":M=" You can also do a functional update '"+J.setter+"("+J.missingDep.substring(0,1)+" => ...)' if you only need '"+J.missingDep+"' in the '"+J.setter+"' call.";break;default:throw new Error("Unknown case.")}}i({node:r,message:"React Hook "+e.getSourceCode().getText(t)+" has "+($(R,"a","missing","include")||$(I,"an","unnecessary","exclude")||$(H,"a","duplicate","omit"))+M,suggest:[{desc:"Update the dependencies array to be: ["+j.map(q).join(", ")+"]",fix:function(e){return e.replaceText(r,"["+j.map(q).join(", ")+"]")}}]})}else{scanForConstructions({declaredDependencies:S,declaredDependenciesNode:r,componentScope:m,scope:y}).forEach((function(e){var n,t=e.construction,a=e.isUsedOutsideOfHook,o=e.depType,s="function"===o?"useCallback":"useMemo",c="function"===o?"definition":"initialization",l="wrap the "+c+" of '"+t.name.name+"' in its own "+s+"() Hook.",u=a?"To fix this, "+l:"Move it inside the "+f+" callback. Alternatively, "+l,p="conditional"===o||"logical expression"===o?"could make":"makes",d="The '"+t.name.name+"' "+o+" "+p+" the dependencies of "+f+" Hook (at line "+r.loc.start.line+") change on every render. "+u;a&&"Variable"===t.type&&"function"===o&&(n=[{desc:"Wrap the "+c+" of '"+t.name.name+"' in its own "+s+"() Hook.",fix:function(e){var n="useMemo"===s?["useMemo(() => { return ","; })"]:["useCallback(",")"],r=n[0],a=n[1];return[e.insertTextBefore(t.node.init,r),e.insertTextAfter(t.node.init,a)]}}]),i({node:t.node,message:d,suggest:n})}))}}else{var X=null;if(k.forEach((function(e,r){e.isStable;var t=e.references;X||t.forEach((function(e){if(!X){var t=e.identifier;if(s.has(t)){for(var a=e.from;"function"!==a.type;)a=a.upper;a.block===n&&(X=r)}}}))})),X){var Y=collectRecommendations({dependencies:k,declaredDependencies:[],stableDependencies:A,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;i({node:t,message:"React Hook "+f+" contains a call to '"+X+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+Y.join(", ")+"] as a second argument to the "+f+" Hook.",suggest:[{desc:"Add dependencies array: ["+Y.join(", ")+"]",fix:function(e){return e.insertTextAfter(n,", ["+Y.join(", ")+"]")}}]})}}}function B(e){for(var r=e.from,t=!1;r.block!==n;)"function"===r.type&&(t=null!=r.block.parent&&"ReturnStatement"===r.block.parent.type),r=r.upper;return t}function q(e){for(var n=e.split("."),r="",t=0;t<n.length;t++){if(0!==t){var a=n.slice(0,t+1).join(".");r+=!0===E.get(a)?"?.":"."}r+=n[t]}return r}function $(e,n,r,t){return 0===e.size?null:(e.size>1?"":n+" ")+r+" "+(e.size>1?"dependencies":"dependency")+": "+joinEnglish(Array.from(e).sort().map((function(e){return"'"+q(e)+"'"})))+". Either "+t+" "+(e.size>1?"them":"it")+" or remove the dependency array."}}return{CallExpression:function(n){var r=getReactiveHookCallbackIndex(n.callee,a);if(-1!==r){var t=n.arguments[r],o=n.callee,s=getNodeWithoutReactNamespace(o).name,c=n.arguments[r+1],l=/Effect($|[^a-z])/g.test(s);if(c||l){switch(t.type){case"FunctionExpression":case"ArrowFunctionExpression":return void f(t,c,o,s,l);case"Identifier":if(!c)return;if(c.elements&&c.elements.some((function(e){return e&&"Identifier"===e.type&&e.name===t.name})))return;var u=e.getSourceCode().getScope(t).set.get(t.name);if(null==u||null==u.defs)return;var p=u.defs[0];if(!p||!p.node)break;if("Variable"!==p.type&&"FunctionName"!==p.type)break;switch(p.node.type){case"FunctionDeclaration":return void f(p.node,c,o,s,l);case"VariableDeclarator":var d=p.node.init;if(!d)break;switch(d.type){case"ArrowFunctionExpression":case"FunctionExpression":return void f(d,c,o,s,l)}}break;default:return void i({node:o,message:"React Hook "+s+" received a function whose dependencies are unknown. Pass an inline function instead."})}i({node:o,message:"React Hook "+s+" has a missing dependency: '"+t.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+t.name+"]",fix:function(e){return e.replaceText(c,"["+t.name+"]")}}]})}else"useMemo"!==s&&"useCallback"!==s||i({node:o,message:"React Hook "+s+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"})}}}}};function collectRecommendations(e){var n=e.dependencies,r=e.declaredDependencies,t=e.stableDependencies,a=e.externalDependencies,i=e.isEffect,o=s();function s(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function c(e,n){var r,t=e,a=_createForOfIteratorHelper(n.split("."));try{for(a.s();!(r=a.n()).done;){var i=r.value,o=t.children.get(i);o||(o=s(),t.children.set(i,o)),t=o}}catch(e){a.e(e)}finally{a.f()}return t}n.forEach((function(e,n){c(o,n).isUsed=!0,function(e,n,r){var t,a=n.split("."),i=e,o=_createForOfIteratorHelper(a);try{for(o.s();!(t=o.n()).done;){var s=t.value,c=i.children.get(s);if(!c)return;r(c),i=c}}catch(e){o.e(e)}finally{o.f()}}(o,n,(function(e){e.isSubtreeUsed=!0}))})),r.forEach((function(e){var n=e.key;c(o,n).isSatisfiedRecursively=!0})),t.forEach((function(e){c(o,e).isSatisfiedRecursively=!0}));var l=new Set,u=new Set;!function e(n,r,t,a){n.children.forEach((function(n,i){var o=a(i);n.isSatisfiedRecursively?n.isSubtreeUsed&&t.add(o):n.isUsed?r.add(o):e(n,r,t,(function(e){return o+"."+e}))}))}(o,l,u,(function(e){return e}));var p=[],f=new Set,d=new Set;return r.forEach((function(e){var n=e.key;u.has(n)?-1===p.indexOf(n)?p.push(n):d.add(n):!i||n.endsWith(".current")||a.has(n)?f.add(n):-1===p.indexOf(n)&&p.push(n)})),l.forEach((function(e){p.push(e)})),{suggestedDependencies:p,unnecessaryDependencies:f,duplicateDependencies:d,missingDependencies:l}}function getConstructionExpressionType(e){switch(e.type){case"ObjectExpression":return"object";case"ArrayExpression":return"array";case"ArrowFunctionExpression":case"FunctionExpression":return"function";case"ClassExpression":return"class";case"ConditionalExpression":return null!=getConstructionExpressionType(e.consequent)||null!=getConstructionExpressionType(e.alternate)?"conditional":null;case"LogicalExpression":return null!=getConstructionExpressionType(e.left)||null!=getConstructionExpressionType(e.right)?"logical expression":null;case"JSXFragment":return"JSX fragment";case"JSXElement":return"JSX element";case"AssignmentExpression":return null!=getConstructionExpressionType(e.right)?"assignment expression":null;case"NewExpression":return"object construction";case"Literal":return e.value instanceof RegExp?"regular expression":null;case"TypeCastExpression":case"TSAsExpression":return getConstructionExpressionType(e.expression)}return null}function scanForConstructions(e){var n=e.declaredDependencies,r=e.declaredDependenciesNode,t=e.componentScope,a=e.scope;function i(e){for(var n=!1,t=0;t<e.references.length;t++){var i=e.references[t];if(i.writeExpr){if(n)return!0;n=!0}else{for(var o=i.from;o!==a&&null!=o;)o=o.upper;if(o!==a&&!isAncestorNodeOf(r,i.identifier))return!0}}return!1}return n.map((function(e){var n=e.key,r=t.variables.find((function(e){return e.name===n}));if(null==r)return null;var a=r.defs[0];if(null==a)return null;if("Variable"===a.type&&"VariableDeclarator"===a.node.type&&"Identifier"===a.node.id.type&&null!=a.node.init){var i=getConstructionExpressionType(a.node.init);if(null!=i)return[r,i]}return"FunctionName"===a.type&&"FunctionDeclaration"===a.node.type?[r,"function"]:"ClassName"===a.type&&"ClassDeclaration"===a.node.type?[r,"class"]:null})).filter(Boolean).map((function(e){var n=e[0],r=e[1];return{construction:n.defs[0],depType:r,isUsedOutsideOfHook:i(n)}}))}function getDependency(e){return"MemberExpression"!==e.parent.type&&"OptionalMemberExpression"!==e.parent.type||e.parent.object!==e||"current"===e.parent.property.name||e.parent.computed||null!=e.parent.parent&&("CallExpression"===e.parent.parent.type||"OptionalCallExpression"===e.parent.parent.type)&&e.parent.parent.callee===e.parent?"MemberExpression"===e.type&&e.parent&&"AssignmentExpression"===e.parent.type&&e.parent.left===e?e.object:e:getDependency(e.parent)}function markNode(e,n,r){n&&(e.optional?n.has(r)||n.set(r,!0):n.set(r,!1))}function analyzePropertyChain(e,n){if("Identifier"===e.type||"JSXIdentifier"===e.type){var r=e.name;return n&&n.set(r,!1),r}if("MemberExpression"!==e.type||e.computed){if("OptionalMemberExpression"!==e.type||e.computed){if("ChainExpression"!==e.type||e.computed)throw new Error("Unsupported node type: "+e.type);var t=e.expression,a=analyzePropertyChain(t.object,n)+"."+analyzePropertyChain(t.property,null);return markNode(t,n,a),a}var i=analyzePropertyChain(e.object,n)+"."+analyzePropertyChain(e.property,null);return markNode(e,n,i),i}var o=analyzePropertyChain(e.object,n)+"."+analyzePropertyChain(e.property,null);return markNode(e,n,o),o}function getNodeWithoutReactNamespace(e,n){return"MemberExpression"!==e.type||"Identifier"!==e.object.type||"React"!==e.object.name||"Identifier"!==e.property.type||e.computed?e:e.property}function getReactiveHookCallbackIndex(e,n){var r=getNodeWithoutReactNamespace(e);if("Identifier"!==r.type)return-1;switch(r.name){case"useEffect":case"useLayoutEffect":case"useCallback":case"useMemo":return 0;case"useImperativeHandle":return 1;default:if(r===e&&n&&n.additionalHooks){var t;try{t=analyzePropertyChain(r,null)}catch(e){if(/Unsupported node type/.test(e.message))return 0;throw e}return n.additionalHooks.callbackIndex(t)}return-1}}function parseAdditionalHooks(e){if("string"==typeof e){var n=new RegExp(e);return{callbackIndex:function(e){return n.test(e)?0:-1}}}if("object"==typeof e)return{callbackIndex:function(n){return"number"==typeof e[n]?e[n]:-1}}}function fastFindReferenceWithParent(e,n){for(var r=[e],t=null;r.length;){if(isSameIdentifier(t=r.shift(),n))return t;if(isAncestorNodeOf(t,n))for(var a=0,i=Object.entries(t);a<i.length;a++){var o=i[a],s=o[0],c=o[1];"parent"!==s&&(isNodeLike(c)?(c.parent=t,r.push(c)):Array.isArray(c)&&c.forEach((function(e){isNodeLike(e)&&(e.parent=t,r.push(e))})))}}return null}function joinEnglish(e){for(var n="",r=0;r<e.length;r++)n+=e[r],0===r&&2===e.length?n+=" and ":r===e.length-2&&e.length>2?n+=", and ":r<e.length-1&&(n+=", ");return n}function isNodeLike(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)&&"string"==typeof e.type}function isSameIdentifier(e,n){return("Identifier"===e.type||"JSXIdentifier"===e.type)&&e.type===n.type&&e.name===n.name&&e.range[0]===n.range[0]&&e.range[1]===n.range[1]}function isAncestorNodeOf(e,n){return e.range[0]<=n.range[0]&&e.range[1]>=n.range[1]}var configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/exhaustive-deps":"warn"}}},rules={"exhaustive-deps":ExhaustiveDeps};exports.configs=configs,exports.rules=rules;
